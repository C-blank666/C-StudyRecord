#include<iostream>
using namespace std;
//缺省参数
void test01(int a = 10, int b = 20, int c = 30) {
	cout << "a:" << a << endl;
	cout << "b:" << b << endl;
	cout << "c:" << c << endl;
}//全缺省打印10,20,30
void test02(int a, int b = 20, int c = 30) {
	cout << "a:" << a << endl;
	cout << "b:" << b << endl;
	cout << "c:" << c << endl;
}//半缺省打印1,20,30
/*void test03(int a=10, int b, int c = 30) {
	cout << "a:" << a << endl;
	cout << "b:" << b << endl;
	cout << "c:" << c << endl;
}这个函数的缺省参数的使用方法是错误的，因为缺省参数的定义是从右到左连续的，不能跳跃给值
*/
//最后当函数的声明与定义分离时，声明和定义不能同时给缺省值，C++规定必须在声明中给缺省值


//函数重载
/*
c++提供函数重载
即同名函数可以同时存在并调用，但是要求函数的参数类型或顺序或数量要有所不同，需要注意到的是仅仅返回值不同
不能实现函数重载，原因是在使用参数相同返回值不同的函数时系统不能区别要调用的函数定义。
*/
void Test03(int a, int b) {
	cout << "整形：" << a << ' ' << b << endl;
}
void Test03(int a, double b) {
	cout << "整形：" << a << ' ' << "浮点型：" << b << endl;
}
void Test03(double a, int b) {
	cout << "浮点型：" << a << ' ' << "整形：" << b << endl;
}
void Test03(int a, int b, int c) {
	cout << "整形：" << a << ' ' << b << ' ' << c << endl;
}


//引用

//引用的本质是一个指针常量
//如：
void test04() {
	int a = 10;
	int& ref = a;//ref是a的别名
	//这里ref本质上是一个指针常量(int* const,这里的const修饰指针变量，即指针指向不能被改变)，虽然语法上不显式的占用内存，
	//但通过结构体测试发现，引用在底层占用与指针相同的内存空间
	int c = 20;
	cout << "a:" << a << ' ' << "ref:" << ref << ' ' << "c:" << c << endl;
	cout << "&a:" << &a << ' ' << "&ref:" << &ref << ' ' << "&c:" << &c << endl;
	ref = c;//这里只是一个赋值，ref的值变为20，则a也变成20
	cout << "a:" << a << ' ' << "ref:" << ref << ' ' << "c:" << c << endl;
	cout << "&a:" << &a << ' ' << "&ref:" << &ref << ' ' << "&c:" << &c << endl;
	//打印的结果中&ref并未改变，因为ref是引用变量，引用变量不能改变指向
	//所以对引用的显式理解是 引用是一个别名，不占用内存，改变引用变量即改变引用变量所引用的值。
	//即时用sizeof对引用进行操作得出的大小也是所引用变量类型的大小
}
//const引用
void test05() {
	//const引用可以引用常量值，因为常量值不可被改变，如果用普通引用会发生权限放大
	const int a = 100;
	const int& ra = a;
	//const引用可以引用一些临时对象
	const int& ref = a * 3;
	const double& ref0 = 2.33;
}


 
//内连函数
//在函数定义前面加上 inline 后，可以直接展开函数使用，不用开辟临时栈帧，提高了程序运行效率
//它解决了传统c语言宏定义的缺点
//但是inline只适用于短小的函数，如果函数的代码量很大，vs编译器会强制不展开（即使加了inline也不展开），因为
//一味的展开会使代码量激增，占用程序的运行内存
inline void test06(int a) {
	cout << a << endl;
}//代码量少，会在release版本下展开（Debug版本不展开，因为要进行调试）


//nullptr
/*C++中NULL可能被定义为字⾯常量0，或者C中被定义为⽆类型指针(void*)的常量。不论采取何种
定义，在使⽤空值的指针时，都不可避免的会遇到⼀些⿇烦，本想通过f(NULL)调⽤指针版本的
f(int*)函数，但是由于NULL被定义成0，调⽤了f(int x)，因此与程序的初衷相悖。f((void*)NULL);
调⽤会报错。
• C++11中引⼊nullptr，nullptr是⼀个特殊的关键字，nullptr是⼀种特殊类型的字⾯量，它可以转换
成任意其他类型的指针类型。使⽤nullptr定义空指针可以避免类型转换的问题，因为nullptr只能被
隐式地转换为指针类型，⽽不能被转换为整数类型。
*/




int main() {
	//test01();
	//test01(1, 2);
	//test01(1, 2, 3);//缺省参数可以给值，也可以不给值，但要注意带缺省参数的函数调⽤，C++规定必须从左到右依次给实参，不能跳跃给实参。
	//test02(1);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Test03(1, 2);
	//Test03(1, 2.33);//类型不同
	//Test03(2.33, 1);//顺序不同
	//Test03(1, 2, 3);//数量不同
	test04();
	return 0;
}
